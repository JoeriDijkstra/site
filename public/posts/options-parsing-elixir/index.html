<!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Personal website">
    
    <link rel="shortcut icon" href="http://localhost:1313/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <link rel="canonical" href="http://localhost:1313/posts/options-parsing-elixir/" />
    <title>Parsing options in Elixir</title>
</head>
<body><header id="banner">
    <h2><a href="http://localhost:1313/">Joeri Dijkstra</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/about/" title="about">about</a>
            </li><li>
                <a href="/projects/" title="projects">projects</a>
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Parsing options in Elixir</h1>
        <div>
                <time>December 29, 2023</time>
            </div>
    </header><p>Options are often done in a keyword list in Elixir. The problem with this is that keyword lists are order-bound. This means that pattern matching is going to be hard the first time, and it is a problem I had when creating MapGrid.</p>
<p>You may expect the pattern to match when you try the following:</p>
<pre tabindex="0"><code>defp work(async: true, should_run: true), do: async_work()
defp work(async: false, should_run: true), do: sync_work()
defp work(_), do: :ok
</code></pre><p>Then you try to run the command:</p>
<pre tabindex="0"><code>work(should_run: true, async: false)
</code></pre><p>But this <strong>will not</strong> match, since it is order dependent and you want to match on multiple options or an arbitrary amount of options it will fail to match.</p>
<p>Here is the way I solved it, it is not the perfect solution, and might not be the only one out there, but I think it makes for an elegant flow which is easily understandable and extendable.</p>
<pre tabindex="0"><code>defp work(opts) do
    opts_map = Enum.into(opts, %{})
    do_work(opts_map)
end

defp do_work(%{async: true, should_run: true}), do: async_work()
defp do_work(%{async: false, should_run: true}), do: sync_work()
</code></pre><p>Now when running the following code it will work:</p>
<pre tabindex="0"><code>work(should_run: true, async: false)
</code></pre><p>This is because keyword lists are order dependent, and maps are not. So when we call the Enum.into function we basically convert it into a map we can easily match on. In my opinion this is a much neater solution than having a list of if-statements to control the flow.</p>
<p>It is also used in the MapGrid code, with multiple optionable features which can be toggled (the options are converted into a map first):</p>
<pre tabindex="0"><code>  defp apply_options(item, options) do
    item
    |&gt; apply_function(options)
    |&gt; reduce_to_keys(options)
  end

  defp apply_function(item, %{item_function: function}), do: function.(item)
  defp apply_function(item, _), do: item

  defp reduce_to_keys(item, %{keys: keys}) do
    Enum.reduce(keys, [], &amp;[{&amp;1, Map.get(item, &amp;1)} | &amp;2])
  end

  defp reduce_to_keys(item, _), do: item
</code></pre><p>Here it will always return the item and I can easily add more functions like this to the pipeline in apply_options. If you think there are other better ways to handle options please let me know.</p>
</article>

        </main><footer id="footer">
    Copyright Â© 2025 Joeri Dijkstra
</footer>
</body>
</html>
